## 📝 TIT (Today I Think)

`/docs/TIT.txt`는 매일 개발 과정에서의 배운 점, 고민한 내용, 적용 아이디어 등을 자유롭게 기록한 개인 메모입니다.
학습 흐름을 자연스럽게 쌓아가기 위해, **초기에는 큰 틀 없이 자유롭게 작성**하며,
**데이터가 충분히 모이면 주제별로 분리**하거나 **velog 포스트로 정리할 예정입니다.**

## DATE: 2025-04-03

### 리팩토링 고려 요소 정리

#### 리팩토링 우선순위 정하기 : 하지 않으면 다음 단계가 불가능한거 / 하지 않으면 배포 불가능한거 / 배포 후 해도 되는거

예외처리 : null만 체크하는 코드 찾기 > 어떻게 개선할지 판단하기 (checked vs unchecked) > 적용
로깅 도입 : 우선 println 다 지우기 > logging이 필요한 부분 판단하기 > 어떤 도구 사용할지 정하기(SLF4J + Logback) > 적용
비즈니스 로직 분리 : 다른 개발자들의 기술 블로그 읽어보기 > 공통적으로 판단하는 기준 추출하기 + 프로젝트 상황에 맞는 기준 분류 > 내 프로젝트에 맞게 적용
DTO Entity 변환 분리 : 왜 필요한지 알아보기 >
클래스 제목 : (코드 배껴 쓰느라 기준이 섞여있음) 다른 github 프로젝트들 찾아보기 > 클래스명 짓는 기준 분류하기(장단점도 조사) > 내 프로젝트에 적용할 클래스 작명 기준 정하기 > 적용
페이징 처리 개선 : 현재 적용된 페이징이 offset인지 cursor인지 다른건지 파악 > 첫 페지는 offset + 다른 페이지는 cursor 적용해보기
트랜잭션 관리 : 보수적으로 트랜잭션 적용해보기 > 성능을 최대화하기 위해 어디까지 트랜잭션을 해제할 수 있는지 적용해보기 > 둘다 성능 테스트 해보기
테스트 코드 작성 : 프로젝트 규모나 특성별로 사용하는 테스트 방법론 알아보기 > 테스트 기준 정하기 > 테스트 툴별 장단점 조사하기 > 테스트 툴 정하기(JUnit5 + Mockito /
SpringBootTest + TestRestTemplate/MockMvc)

#### 우선순위 분류

1. 배포 불가능 + 당장 해야함 : 최소한의 예외 처리, 로깅. 트랜잭션
2. 배포 불가능 + 당장은 아님 : 테스트 코드, 페이징 처리 개선, 예외 처리
3. 배포 후 가능 : 비즈니스 로직 분리, DTO Entity 변환 분리, 클래스명 정리

---

### 계층별 예외 처리

**Service 계층**
- 비즈니스 로직 처리 중 예외 상황이 발생하면 `throw`로 커스텀 예외를 던짐
- 결과가 없을 수 있는 경우는 `Optional<T>`을 반환하여 유연하게 처리
- 내부 로직에서는 상황에 따라 `null` 사용도 허용됨
  **Controller 계층**
- Service에서 발생한 예외는 직접 처리하지 않고 그대로 전파
- Spring이 `@ExceptionHandler`, `@ControllerAdvice`를 통해 예외를 자동으로 처리하여
  적절한 HTTP 상태 코드와 메시지를 클라이언트에 반환함
  -> @RestController를 사용하는 경우, 예외가 발생하면 @ControllerAdvice가 JSON 응답으로 변환
  (단순 뷰가 아닌 API 응답이라는 점에서 차이 있음)
  **예외 클래스**
- 실무에서는 대부분 `RuntimeException`을 상속받아 커스텀 예외를 정의함
- 각 예외는 상황에 맞는 명확한 이름과 예외 메시지를 포함하여 설계함

### 예외 처리 흐름 (REST API 전환 전 기준)

[클라이언트 요청]
→
[Controller 호출]
→
[Service 호출 (비즈니스 로직)]
→
예외 발생 (throw new ...)
→
[Spring이 예외 감지 → @ControllerAdvice or @ExceptionHandler]
→
[에러 뷰 페이지 반환 or 리다이렉트]

### .orElseThrow() 리팩토링

→ Optional을 반환하고 (findById, return) null 반환 시 예외를 throw하려고 할 때 사용
→ findById().get() 사용한 경우 리펙토링
BoardEntity board = boardRepository.findById(savedId)
.orElseThrow(() → new ResourceNotFoundException("게시글 저장 후 조회 실패: id = " + savedId));

---

### REST API 리팩토링 고민

- 현재 프로젝트는 정적 뷰 리소스 기반임.
- 따라서 rest api를 만들기 위해서는 controller에서 view만 분리하고 나머지를 rest로 만들면 될듯
- 하지만 rest api를 만들어야 하는 이유부터 고민해 봐야함. 또 설계가 선행되어야함.
- 게시판 구조는 자원 중심 구조로 설계하기가 쉽고 일관성 있음.
- 또 나는 백엔드만 설계하고 있기 때문에 구조적으로 의미있음.
- 문서 자동화 하고 싶음
- 나는 성능 최적화, 예외, 인증 등 기능 구현 또한 중요하니까 나중에 기능 흐름에 익숙해졌을 때 리팩토링 하는게 좋아보임