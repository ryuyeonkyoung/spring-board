## DATE: 2025-04-04

### Builder

- @Builder 어노테이션을 사용하면 .builder(), .build() 메서드로 필요한 필드를 선택적으로 설정하여 객체를 생성할 수 있음
- 유효성 검사는 Builder 내부가 아닌 DTO와 컨트롤러 계층에서 수행하는 것이 일반적임
- @NotBlank, @Valid 이용

주의점

- Lombok의 @Builder는 내부적으로 **모든 필드를 포함한 생성자** 하나를 만들어 해당 생성자를 기반으로 빌더 객체를 생성한다.
    - 빌더 메서드를 통해 설정하지 않은 필드는 기본값(null 또는 초기화된 값)이 적용된다.
    - 다양한 생성자를 만드는 건 같이 사용하는 롬복의 @AllArgsConstructor, @NoArgsConstructor, @RequiredArgsConstructor과 관련되어 있다.
- Entity 계층에서 JPA와의 충돌 주의 : @AllArgsConstructor
- @Builder.Default 없이는 초기값이 무시될 수 있음.
- Builder는 객체 생성이라는 하나의 역할만 담당하게 하기. (유효성 검사는 DTO에서 진행)

---

### MapStruct

- Builder 패턴은 필드를 선택적으로 조합해 객체를 생성할 수 있지만, 매번 모든 필드를 지정해야 하는 경우에는 오히려 번거로울 수 있음.
- 모든 필드를 자동으로 변환해야 하는 경우에는 MapStruct가 더 유리함
- 예: @Mapper(componentModel = "spring")  
  → boardMapper.toBoardDTO(boardEntity) 형태로 호출 가능

---

### final

#### 계층별 final 사용 여부와 이유

1. DTO(권장) : 클라이언트의 값 변경 방지, 불변성 보장, 명확한 설계
2. Entity(지양) : JPA가 값 변경을 감지해야 함 (Dirty Checking)
3. Service(권장) : DI 받은 의존성(예: Repository)의 변경을 방지하고, 의도한 불변성을 명확히 하기 위해
4. Config(권장) : 변경되면 안 되는 설정값에 이용
5. Controller(없음) : 상태를 갖지 않음

#### final과 builder 패턴

- final은 해당 필드나 계층의 불변성을 보장하기 위해 사용
- Builder는 setter 없이 가독성 좋게 객체를 생성할 수 있게 해주는 패턴
- 단, 일부 필드만 final일 경우 @Builder 사용 시 생성자 요구 조건과의 충돌이 생길 수 있음
    - final 필드 전부를 포함하는 생성자를 수동으로 정의하고, 그 생성자에 @Builder를 명시해 사용하는 방식으로 해결 가능
    - final이 아닌 필드들은 setter로 따로 주입해야 함.