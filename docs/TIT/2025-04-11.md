## DATE: 2025-04-11

## Offset Paging vs Cursor Paging

### Offset Paging - 게시판 등 일반적인 페이징

- **페이지 번호와 크기**로 조회 (OFFSET x LIMIT y)

- 페이징 메타데이터: 포함 (총 페이지 수, 현재 페이지 번호 등)
- 반환 형태: Page 객체 (데이터 + 메타데이터)
- 성능: 페이지 번호가 커질수록 성능 저하 (OFFSET은 앞 데이터를 모두 스캔 후 버림)
    - 예를 들어, LIMIT 10 OFFSET 10000은 10000개를 스캔한 후 10개만 리턴

### Cursor Paging - 대용량 로그, 무한스크롤 등 성능이 중요한 경우

- **마지막 데이터 기준**으로 다음 페이지 조회 (WHERE id < cursor)

- 페이징 메타데이터: 미포함 (다음 커서 값과 다음 페이지 여부만 제공)
- 반환 형태: 단순 List (데이터만 반환)
- 성능: 일정한 성능 (인덱스 기반 조회)

### 성능 면에서의 Offset 페이징과 Cursor 페이징

- Offset 페이징은 OFFSET이 클수록 DB가 앞의 N개 행을 스캔하고 버려야 해서 느려짐
    - 예를 들어, LIMIT 10 OFFSET 10000은 무려 10000개를 스캔한 후 10개만 리턴
- Cursor 페이징은 WHERE id < ?처럼 인덱스를 타고 바로 탐색 가능

→ 첫 페이지는 기준 커서가 없기 때문에 Offset Paging을 사용하고, 이후 페이지는 Cursor Paging을 사용하는 것이 좋음

---

## MapStruct

- Entity ↔ DTO 간 매핑 코드를 자동으로 생성해주는 컴파일 타임 코드 생성기
- 수작업 매핑 코드의 반복을 줄이고, 유지보수를 쉽게 하기 위해 사용함

### 1. 언제 쓰는지

Entity ↔ DTO 간 변환 로직이 많고 복잡할 때 사용하며, 다음과 같은 상황에서 특히 유리함:

- DTO 필드 수가 많거나 구조가 반복될 때
- 여러 API에서 동일한 매핑 로직을 재사용할 때
- Controller/Service에서 매핑 코드가 너무 많아져 비즈니스 로직 가독성을 해칠 때
- ModelMapper, BeanUtils.copyProperties() 대비 성능/정확성을 중요시할 때

### 2. 쓰는 방법

1. 의존성 추가

```xml
dependencies {
        implementation 'org.mapstruct:mapstruct:1.5.5.Final'
        annotationProcessor 'org.mapstruct:mapstruct-processor:1.5.5.Final'
        }
```

2. 매핑 인터페이스 생성

```java

@Mapper(componentModel = "spring")
public interface BoardMapper {
    BoardSummaryDTO toSummaryDTO(BoardEntity entity);

    List<BoardSummaryDTO> toSummaryDTOs(List<BoardEntity> entities);
}
```

3. 사용 – Service 등에서 주입

```java

@Autowired
private BoardMapper boardMapper;

...

        return boardEntities.

map(boardMapper::toSummaryDTO);
```

### 3. 주의할 점

- 필드 이름 다를 때
- 양방향 매핑 루프 주의
- Lombok과 함께 사용 시 @Builder.Default 주의 → 기본 생성자/Setter 필요
- 테스트 시 코드가 생성되지 않음
- annotaionProcessor 인식 문제로 IDE에서 오류 발생할 수 있음 → 빌드는 정상적으로 됨

### 4. 선택 전략

1. MapStruct : 대부분의 상황에서 사용. DTO 구조가 복잡하고 자주 바뀔 때 유리
2. 수동 매핑 (Page<T>의 .map(...) 메서드 사용) : 디버깅시 에러 라인 추적이 쉬움

---

